# React

1.渲染属性组件：指拥有render属性的组件，其值是一个渲染函数，用来将函数入参中的值渲染到一个组件中。
2.高阶组件：即参数为组件，返回值为新组件的函数。其是将组件转换为另一个组件的组件。

# 状态管理
1.使用状态响应输入。
2.选择状态结构。
3.在组件间共享状态。
4.保留和重置状态。
5.提取逻辑到reducer中。
6.使用Context进行深层数据传递。
7.使用Reducer和Context进行状态扩展。

## 使用状态响应输入
    即编写UI时，根据不同状态来编写对应的UI，然后在触发不同状态时，展现不同UI。而不用在进行某个操作时，使用代码操作UI改变。

## 选择状态结构
    即设计UI的状态时，要尽量原子化，不要设计复杂的状态。复杂的状态可以通过简单的状态进行组合得到。

## 在组件间共享状态
    要在组件间共享状态，使用状态提升。即将相关状态移动到父元素来进行状态的提升。

## 保留和重置状态
    key: React组件在渲染时，会根据id是否变化，来决定是否重新渲染组件。

## 提取逻辑到reducer中
    为了简化代码，可以将所有异步操作相关的处理逻辑移到reducer函数中进行集中处理，避免逻辑的碎片化。

## 使用Context进行深层数据传递
    为了解决层层传递props的麻烦，可以使用Context来解决。

## 使用Reducer和Context进行状态扩展


# 总结:

1.状态设计：
    (1)根据UI组件在不同业务状态下的表现来设计组件的状态。
    (2)在设计组件的状态时，要遵循原子化原则，避免复杂的组件状态（对于复杂的业务状态应该通过原子化的组件状态计算获得）。

2.状态共享：
    (1)提升到父级；
    (2)使用Context: 即创建一个上下文的Context对象，然后通过在父级引入它并修改它的值，在子级中通过引入Context对象获取
    (3)使用全局的State：
    (4)组件组合: 即将某个深层嵌套的子级组件提升到某个父级，然后再将其整个组件作为父组件的某个属性传递下去。

3.组件的重新渲染逻辑：见diff算法。


# diff算法
三个假设：
1.Web UI中DOM 节点跨层级的移动操作特别少，可以忽略不计。
2.拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。
3.对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。  

## tree diff
基于假设1，所以比较的时候只针对同一层级进行比较。若同一层级中的少了某个节点，就会直接将其及其子节点删除；若同一层级中多了某个节点，则直接新建该节点。

## component diff
基于假设2，对于类型不同的组件，则直接进行重新创建；对于同类型的组件才继续进行比较。

## element diff
基于假设3，对于同一层级的元素，React对少了的元素进行直接删除，对于多了的元素直接进行创建，对于位置变动了的元素则进行移动位置。


# 参考文献见：
https://zhuanlan.zhihu.com/p/103187276
